# 继承与派生
## 29.01  
新的类B如果拥有类A的全部特点，把A作为基类，B作为基类的派生类（也成子类）。  
派生类可以扩充新的成员变量和成员函数，可以独立使用，不依赖与基类     
派生类的各个成员函数中，不能访问基类中的private成员。
class 派生类名 ： public 基类名
{
};
成员函数名字一样，行为不一样为覆盖。
派生类对象中，包含着基类对象，存储位置位于新增成员变量之前。  
##   30.02
继承关系：“是”关系。
-基类A，B是基类A的派生类
-逻辑上要求：“一个类B对象也是一个类A对象”。
复合关系：“有”关系
-一般逻辑上要求D对象是C对象的固有属性或组成部分
-类C中有成员变量k，k是类D的对象
##  31.03
基类与派生类有同名成员
```
class base{
int j;
public:
int i;
void func()
};
class derived:public base{
public:
int i;
void access();
void func();
};
void derived::access()
{
j=5;//error
i=5;//引用的是派生类的i
base::i=5;//引用的是基类的i
func();//派生类的
base::func();//基类的
}
derived obj;
obj.i=1;
obj.base::i=1;
```
一般不定义同名成员变量  
基类的private成员：可以被基类的成员函数、基类的友元函数访问  
private和protected之间的区别只在基类派生的类中才会表现出来。  
派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。  
## 32.04
派生类的构造函数
派生类的对象包含基类对象，执行派生类构造函数前，先执行基类的构造函数。   
派生类交代基类初始化，具体形式：  
构造函数名(形参表):基类名(实参表){}  
需要利用初始化列表，列表可以用基类的私有成员。（因为不能直接调用）   
在执行一个派生类的构造函数之前，总是先执行基类的构造函数。  
调用基类构造函数的两种方式
显式方式：
派生类的构造函数中由基类的构造函数提供参数(初始化列表)
隐式方式：
派生类的构造函数中，省略基类构造函数时
派生类的构造函数，自动调用基类的默认构造函数
派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数
## 33.05
public继承的赋值兼容规则
派生类的对象可以赋值给基类对象
派生类对象可以初始化基类引用
派生类对象的地址可以赋值给基类指针
```ruby
class base{  };
class derived:public base{  };
base b;
derived d;
b=d;
base&br=d;
base *pb=&b;
```
 类A派生类B，类B派生类C
 则类A是类B的直接基类，类A是类C的间接基类
 在声明派生类时，只需要列出它的直接基类
 派生类沿着类的层次自动向上继承它的间接基类
 
